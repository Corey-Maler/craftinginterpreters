import fs from "fs";
import path from "node:path";

const fileName = process.argv[2];

class Writter {
  constructor(public filePath: string) {}
  content: string = "";

  println(s: string) {
    this.content += s + "\n";
  }

  toString() {
    return this.content;
  }

  write() {
    fs.writeFileSync(path.resolve(__dirname, this.filePath), this.content);
  }
}

class GenerateAst {
  constructor(outputDir: string) {
    this.defineAst(outputDir, "Expr", [
      "Assign   : Token name, Expr value",
      "Binary   : Expr left, Token operator, Expr right",
      "Call     : Expr callee, Token paren, Array<Expr> args",
      "Get      : Expr obj, Token name",
      "Grouping : Expr expression",
      "Literal  : any value",
      "Logical  : Expr left, Token operator, Expr right",
      "Set      : Expr obj, Token name, Expr value",
      "Super    : Token keyword, Token method",
      "This     : Token keyword",
      "Unary    : Token operator, Expr right",
      "Variable : Token name",
    ]);

    this.defineAst(
      outputDir,
      "Stmt",
      [
        "Block      : Stmt[] statements",
        "Class      : Token name, Nullable<Variable> superklass, Array<Fnction> methods",
        "Expression : Expr expression",
        // js does not like word Function
        "Fnction   : Token name, Array<Token> params, Array<Stmt> body",
        "If         : Expr condition, Stmt thenBranch, Nullable<Stmt> elseBranch",
        "Print      : Expr expression",
        "Return     : Token keyword, Nullable<Expr> value",
        "Var        : Token name, Nullable<Expr> initializer",
        "While      : Expr condition, Stmt body",
      ],
      `import { Expr, Variable } from './Expr';

import { Nullable } from '../utils'; `
    );
  }

  private defineImports(writter: Writter) {
    writter.println("import { Token } from '../src/Token';");
  }

  private defineAst(
    outputDir: string,
    baseName: string,
    types: string[],
    header = ""
  ) {
    const filePath = outputDir + "/" + baseName + ".ts";
    const writter = new Writter(filePath);

    writter.println(`
// This code is autogenerated, check generateAst.ts
`);

    writter.println(header);
    this.defineImports(writter);

    this.defineVisitor(writter, baseName, types);

    writter.println(`
export abstract class ${baseName} {
  abstract accept<R>(visitor: Visitor<R>): R;
};

    `);

    for (const type of types) {
      const className = type.split(":")[0].trim();
      const fields = type.split(":")[1].trim();
      this.defineType(writter, baseName, className, fields);
    }

    writter.write();
  }

  private defineType(
    writter: Writter,
    baseName: string,
    className: string,
    fields: string
  ) {
    const javaToTS = fields
      .split(",")
      .map((part) => {
        const [tp, nam] = part.trim().split(" ");
        return `public ${nam}: ${tp}`;
      })
      .join(", ");
    writter.println(`export class ${className} extends ${baseName} {
      constructor(${javaToTS}) {
        super();
      };`);

    writter.println(`
  accept<R>(visitor: Visitor<R>): R {
    return visitor.visit${className}${baseName}(this);
  }
`);

    writter.println("}");
  }

  private defineVisitor(writter: Writter, baseName: string, types: string[]) {
    writter.println("export interface Visitor<R> {");

    for (const type of types) {
      const typeName = type.split(":")[0].trim();

      writter.println(
        `\tvisit${typeName}${baseName}(${baseName.toLowerCase()}: ${typeName}): R`
      );
    }

    writter.println("}");
  }
}

const g = new GenerateAst(fileName);
