import fs from "fs";
import path from "node:path";

const fileName = process.argv[2];

class Writter {
  constructor(public filePath: string) {}
  content: string = "";

  println(s: string) {
    this.content += s + "\n";
  }

  toString() {
    return this.content;
  }

  write() {
    fs.writeFileSync(path.resolve(__dirname, this.filePath), this.content);
  }
}

class GenerateAst {
  constructor(outputDir: string) {
    this.defineAst(outputDir, "Expr", [
      "Assign   : Token name, Expr value",
      "Binary   : Expr left, Token operator, Expr right",
      "Grouping : Expr expression",
      "Literal  : any value",
      "Unary    : Token operator, Expr right",
      "Variable : Token name"
    ]);

    this.defineAst(outputDir, "Stmt", [
      "Block      : Stmt[] statements",
      "Expression : Expr expression",
      "Print      : Expr expression",
      "Var        : Token name, Nullable<Expr> initializer",
    ], `import { Expr } from './Expr';

import { Nullable } from '../utils'; `);
  }

  private defineImports(writter: Writter) {
    writter.println("import { Token } from '../src/Token';");
  }

  private defineAst(outputDir: string, baseName: string, types: string[], header = '') {
    const filePath = outputDir + "/" + baseName + ".ts";
    const writter = new Writter(filePath);

    writter.println(`
// This code is autogenerated, check generateAst.ts
`);

    writter.println(header);
    this.defineImports(writter);

    this.defineVisitor(writter, baseName, types);

    writter.println(`
export abstract class ${baseName} {
  abstract accept<R>(visitor: Visitor<R>): R;
};

    `);

    for (const type of types) {
      const className = type.split(":")[0].trim();
      const fields = type.split(":")[1].trim();
      this.defineType(writter, baseName, className, fields);
    }

    writter.write();
  }

  private defineType(
    writter: Writter,
    baseName: string,
    className: string,
    fields: string
  ) {
    const javaToTS = fields
      .split(",")
      .map((part) => {
        const [tp, nam] = part.trim().split(" ");
        return `public ${nam}: ${tp}`;
      })
      .join(", ");
    writter.println(`export class ${className} extends ${baseName} {
      constructor(${javaToTS}) {
        super();
      };`);

    writter.println(`
  accept<R>(visitor: Visitor<R>): R {
    return visitor.visit${className}${baseName}(this);
  }
`)

    writter.println("}");
  }

  private defineVisitor(writter: Writter, baseName: string, types: string[]) {
    writter.println("export interface Visitor<R> {");

    for (const type of types) {
      const typeName = type.split(":")[0].trim();

      writter.println(
        `\tvisit${typeName}${baseName}(${baseName.toLowerCase()}: ${typeName}): R`
      );
    }

    writter.println("}");
  }
}

const g = new GenerateAst(fileName);
